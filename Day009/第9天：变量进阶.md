# 100天精通Python（基础篇）——第9天：变量进阶

###  

### **目标**

- 变量的引用：变量和数据的关系，就像是一对默契的搭档
- 可变和不可变类型：数据的特性，有些数据像变色龙一样，可以改变，有些则像石头一样，一成不变
- 局部变量和全局变量：变量的作用范围，就像是房间里的家具和整栋楼的装饰

### **一. 变量的引用**

> - 变量和数据就像是一对默契的搭档，总是黏在一起的
> - 在 `Python` 中，函数的参数传递和返回值都是靠引用传递的，就像是传递一张地址纸条一样

#### **1.1 引用的概念**

在 `Python` 中

- **变量** 是一个名字，**数据** 是一个实实在在的东西
- **数据** 存储在内存中的某个地方
- **变量** 中保存着数据在内存中的地址
- **变量** 中记录数据的地址，就叫做**引用**
- 使用 `id()` 函数可以查看变量中保存数据的内存地址

> 注意：如果变量已经有了一个引用，当给它赋值的时候，就像是贴了一张新的地址纸条
>
> - 变量不再指向之前的数据
> - 变量改为指向新赋值的数据

#### **1.2** `变量引用` 的示例

在 `Python` 中，变量的名字就像是一张标签，贴在数据上面

- 假设我们定义了一个整数变量 `a`，并且赋值为 `1`

| **代码** | **图示**                                                     |
| -------- | ------------------------------------------------------------ |
| a = 1    | ![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSHpTLUK2hpyHzVNKIInabE1kWNXlMzADovrBmX1pMWeOR4LTiaWYZsUQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) |

- 让我们来玩一个有趣的游戏！让我们给变量 `a` 一个特殊的任务，让它变成一个真正的“2”！就像这样：`a = 2`。现在，变量 `a` 就是一个魔法数字了，它的值是2。快来看看它的魔力吧！

| **代码** | **图示**                                                     |
| -------- | ------------------------------------------------------------ |
| a = 2    | ![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSxgNotZicE0RSsmalLDDal5oc6KtEnuAqnEHkYgchsxxg5Q5P85FjeZQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) |

- 定义一个整数变量 `b`，并且将变量 `a` 的值赋值给 `b`

| **代码** | **图示**                                                     |
| -------- | ------------------------------------------------------------ |
| b = a    | ![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSV8mnFM9icRCFxQGdWPLS2av5qyyouhibvbdqWPDZYYQT5MWaGd3rtnxg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) |

> 变量 `b` 是第 2 个贴在数字 `2` 上的标签

#### **1.3 函数的参数和返回值的传递**

在 `Python` 中，函数的 **实参**/**返回值** 都是是靠 **引用** 来传递来的

```python
def test(num):
    print("-" * 50)
    print("%d 在函数内的内存地址是 %x" % (num, id(num)))
    result = 100
    print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
    print("-" * 50)
    return  result

a = 10
print("调用函数前 内存地址是 %x" % id(a))
r = test(a)
print("调用函数后 实参内存地址是 %x" % id(a))
print("调用函数后 返回值内存地址是 %x" % id(r))
```

### **二. 可变和不可变类型**

- **不可变类型**，就像一位顽固的老人，内存中的数据一旦确定就不肯改变：
    - 数字类型 `int`, `bool`, `float`, `complex`, `long(2.x)`，它们就像是数学题中的不可变常数，一旦确定就无法改变。
    - 字符串 `str`，就像是一串坚固的钢铁链，每个字符都被固定在原位，无法被改变。
    - 元组 `tuple`，就像是一个封闭的宝盒，一旦创建，里面的元素就无法被添加、删除或修改。
- **可变类型**，就像是一位灵活的变色龙，内存中的数据可以随意改变：
    - 列表 `list`，就像是一个可以随意添加、删除和修改元素的容器，非常灵活。
    - 字典 `dict`，就像是一个智能的电话簿，可以根据需要添加、删除和修改联系人信息。

```python
a = 1
a = "hello"
a = [1, 2, 3]
a = [3, 2, 1]
```

```python
demo_list = [1, 2, 3]
print("定义列表后的内存地址 %d" % id(demo_list))
demo_list.append(999)
demo_list.pop(0)
demo_list.remove(2)
demo_list[0] = 10
print("修改数据后的内存地址 %d" % id(demo_list))
demo_dict = {"name": "小明"}
print("定义字典后的内存地址 %d" % id(demo_dict))
demo_dict["age"] = 18
demo_dict.pop("name")
demo_dict["name"] = "老王"
print("修改数据后的内存地址 %d" % id(demo_dict))
```

> 注意：字典的 `key` **只能使用不可变类型的数据**

**注意**

1. **可变类型**的数据变化，就像是变魔术一样，通过 **方法** 来实现的。
2. 如果给一个可变类型的变量，赋值了一个新的数据，就像是换了个新朋友一样，**引用会修改**。
    - 变量 **不再** 对之前的数据引用，就像是失去了联系一样。
    - 变量 **改为** 对新赋值的数据引用，就像是交了新朋友一样。

#### **哈希** `(hash)`

- `Python` 中内置有一个名字叫做 `hash(o)` 的函数，就像是一个魔法师一样。
    - 接收一个 **不可变类型** 的数据作为 **参数**，就像是给魔法师提供材料一样。
    - **返回** 结果是一个 **整数**，就像是魔法师施展魔法后的结果一样。
- `哈希` 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**，就像是给数据贴上了标签一样。
    - **相同的内容** 得到 **相同的结果**，就像是相同的人指纹一样。
    - **不同的内容** 得到 **不同的结果**，就像是不同的人指纹一样。
- 在 `Python` 中，设置字典的 **键值对** 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**，就像是给字典建立了索引一样。
    - 键值对的 `key` 必须是不可变类型数据，就像是给字典的索引加了锁一样。
    - 键值对的 `value` 可以是任意类型的数据，就像是字典的值可以是各种各样的东西一样。

### **三. 局部变量和全局变量**

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**，就像是一个私人秘密一样。
- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**，就像是一个大家都知道的事情一样。

> 提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护！但是在Python中，我们可以开个小小的玩笑。

#### **3.1 局部变量**

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**，就像是一个只在家里使用的物品一样。
- 函数执行结束后，**函数内部的局部变量，会被系统回收**，就像是使用完后的纸巾会被扔掉一样。
- 不同的函数，可以定义相同的名字的局部变量，但是 **彼此之间** 不会产生影响，就像是同名的人在不同的城市一样。

##### **局部变量的作用**

- 在函数内部使用，**临时** 保存 **函数内部需要使用的数据**，就像是在家里临时存放东西一样。

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
def demo1():    num = 10    print(num)    num = 20    print("修改后 %d" % num) def demo2():    num = 100    print(num)demo1()demo2()print("over")
```

##### **局部变量的生命周期**

- 所谓 **生命周期** 就是变量从 **被创造** 到 **被系统回收** 的过程，就像是一个小生命的一天。
- **局部变量** 在 **函数执行时** 才会被创造，就像是在函数里面才会有人出生。
- **函数执行结束后** 局部变量 **被系统回收**，就像是函数结束后，人就回到了虚无之中。
- **局部变量在生命周期** 内，可以用来存储 **函数内部临时使用到的数据**，就像是临时存放在脑袋里的小秘密。

#### **3.2 全局变量**

- **全局变量** 是在 **函数外部定义** 的变量，所有函数内部都可以使用这个变量，就像是全世界都知道的秘密。

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
# 定义一个全局变量num = 10 def demo1():    print(num) def demo2():    print(num)demo1()demo2()print("over")
```

**注意啦！** 当函数执行时，它会像个调皮鬼一样，去寻找变量的踪迹：

1. 首先，它会在自己的小屋里（函数内部）找有没有和指定名称一样的局部变量，如果找到了，它会毫不犹豫地使用它。
2. 如果在自己的小屋里找不到，它会跑出去到外面的大街上（函数外部）看看有没有和指定名称一样的全局变量，如果找到了，它会高兴地使用它。
3. 如果连在外面的大街上都找不到，那它就会生气地抛出一个错误，说“我找不到这个变量啊！”

##### 1) 函数不能直接改变全局变量的身份证

- 全局变量就像是在函数外面定义的变量，所有的函数都可以认识它。

> 提示：在其他编程语言中，大多数人都不喜欢用全局变量，因为它的范围太广，会让程序变得难以维护！

- 在函数里面，你可以通过全局变量的名字来获取对应的数据。
- 但是，你可不能直接改变全局变量的身份证哦！也就是说，你不能用赋值语句来改变全局变量的值。

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
num = 10 def demo1():    print("demo1" + "-" * 50)    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已    num = 100    print(num) def demo2():    print("demo2" + "-" * 50)    print(num)demo1()demo2()print("over")
```

> 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值

##### **2) 在函数内部修改全局变量的值**

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
num = 10 def demo1():    print("demo1" + "-" * 50)    # global 关键字，告诉 Python 解释器 num 是一个全局变量    global num    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已    num = 100    print(num) def demo2():    print("demo2" + "-" * 50)    print(num)demo1()demo2()print("over")
```

##### **3) 全局变量定义的位置**

- 为了让所有的函数都能够顺利享用全局变量的"盛宴"，我们需要在它们之前"摆上桌"。就像是在一场盛大的宴会上，主菜之前总得先上几道开胃菜一样，全局变量也需要在其他函数之前先定义好。这样，所有的函数才能够尽情地享受全局变量的美味！记住，在Python的世界里，顺序是非常重要的哦！

- 
- 
- 
- 
- 
- 
- 
- 
- 

```
a = 10 def demo():    print("%d" % a)    print("%d" % b)    print("%d" % c)b = 20demo()c = 30
```

**注意**

- 哎呀呀，这个全局变量 c 真是个调皮鬼！它竟然在函数调用之后才冒出来，结果导致程序报错了！这就好像是在吃饭的时候突然有人把饭碗藏起来，让你手忙脚乱地找不到东西吃一样。所以，记住，在执行函数之前，一定要先定义好全局变量，不然程序会闹别扭哦！

**代码结构示意图如下**

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwS5WQjUpkJFIa2EPiaQFfpwDbOr0OpcQhjq2Mz3Eu73wV3BvicdL4EhKfA/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### **4) 全局变量命名的建议**

为了避免全局变量和局部变量之间的混淆，有些公司在定义全局变量时提出了一些有趣的要求。比如，他们建议在全局变量名前面加上 `g_` 或者 `gl_` 的前缀，这样一来，你就能一眼看出哪些变量是全局的，哪些是局部的啦！

嗯，就像给全局变量穿上一件醒目的外套，让它们在代码中脱颖而出。这样一来，你就不会在代码中迷失方向，不知道哪些变量是全局的，哪些是局部的了。而且，这种命名规范也能让其他开发者更容易理解你的代码，毕竟，全局变量可是大家共享的资源呢！

所以，记住，在定义全局变量时，给它们加上 `g_` 或者 `gl_` 的前缀，让它们在代码中一目了然，让你的代码更加清晰易读！

> 提示：具体的要求格式，各公司要求可能会有些差异