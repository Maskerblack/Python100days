# 100天精通Python（基础篇）——第13天：面向对象基础语法



## **目标**

- `dir` 内置函数：探索对象的方法和属性
- 定义简单的类：创建自己的对象
- 方法中的 `self` 参数：让方法知道自己是谁
- 初始化方法：给对象一个良好的起点
- 内置方法和属性：Python为我们提供的特殊功能

## **1. dir 内置函数（知道）**

在Python的世界里，对象无所不在。我们之前学习的变量、数据、函数，它们都是对象。

要验证一个对象是否存在，有两种方法：



1. 在标识符或数据后输入一个 `.`，然后按下 **TAB** 键，Python会展示该对象能够调用的方法列表。
2. 使用内置函数 `dir`，传入标识符或数据，可以查看对象内的所有属性及方法。



**提示**：`__方法名__` 格式的方法是Python提供的内置方法或属性，稍后会给大家介绍一些常用的内置方法和属性。



| **方法名** | **类型** | **作用**                                     |
| ---------- | -------- | -------------------------------------------- |
| `__new__`  | 方法     | **创建对象**时，会被 **自动** 调用           |
| `__init__` | 方法     | **对象被初始化**时，会被 **自动** 调用       |
| `__del__`  | 方法     | **对象被从内存中销毁**前，会被 **自动** 调用 |
| `__str__`  | 方法     | 返回**对象的描述信息**，print 函数输出使用   |



利用好 `dir()` 函数！这个函数简直就是你的 Python 导航仪，它可以帮助你探索和了解各种对象的属性和方法。你可以把它想象成是你的 Python 世界的地图，告诉你每个对象都有哪些“秘密武器”。

现在，让我来给你们演示一下 `dir()` 函数的魔力。假设你想知道字符串对象有哪些可用的方法，你只需要输入 `dir(str)`，然后按下回车。嗯，看到了吗？这些方法就像是一群小精灵，等着你去调用它们。你可以使用这些方法来操作字符串，比如翻转它们、拼接它们，甚至是把它们变成大写或小写。

不仅如此，`dir()` 函数还可以帮助你探索其他对象，比如列表、字典、甚至是模块。只要你想了解某个对象的“秘密武器”，就输入 `dir(对象名)`，然后按下回车。这些对象的属性和方法就会像魔法一样展现在你面前。

**注意**，`dir()` 函数返回的结果是一个列表，里面包含了对象的所有属性和方法。所以，你可以使用索引来访问特定的属性或方法。比如，`dir(str)[0]` 就可以获取到字符串对象的第一个属性或方法。

好了，现在你知道了如何利用 `dir()` 函数来探索 Python 的世界了。记住，这个函数就像是你的导航仪，帮助你找到正确的方向。不要害怕去尝试和探索，因为只有这样，你才能真正掌握 Python 的精髓！

希望这个幽默的教程能够帮助你更好地学习 Python。记住，学习应该是一件有趣的事情，所以保持好心情，继续探索吧！加油！



## **2. 定义简单的类（只包含方法）**

**面向对象** 是 **更大** 的 **封装**，就像是把一只猫装进了一个神奇的盒子里。这个盒子就是一个类，里面装着猫的各种行为，比如跳跃、喵喵叫、抓老鼠等等。当我们用这个类创建出来的对象，就好像是打开了盒子，猫就可以直接展现出它的各种本领了！

想象一下，你有一个类叫做"猫"，里面有一个方法叫做"跳跃"，还有一个方法叫做"喵喵叫"。当你用这个类创建出来的对象，比如叫做"小花"，你只需要调用小花的"跳跃"方法，它就会优雅地跳起来；调用小花的"喵喵叫"方法，它就会发出咪咪的声音。是不是很神奇？

所以，面向对象就是把一堆相关的方法封装在一个类里面，让我们可以方便地创建对象并调用这些方法。这样，我们就可以像和一个真实存在的猫一样与对象进行互动了！

### **2.1 定义只包含方法的类**

在 Python 中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:
    def 方法1(self, 参数列表):
        pass
    def 方法2(self, 参数列表):
        pass
```



**方法** 的定义格式和之前学习过的**函数** 几乎一样，就像一对双胞胎兄弟，长得几乎一模一样，只是名字不同。

区别在于第一个参数必须是 `self`，这就像是给方法穿上了一件特殊的衣服，让它与众不同。大家暂时先记住这个规矩，稍后我会给你介绍 `self` 的真正身份。

另外，**类名** 的 命名规则 要符合 **大驼峰命名法**，这就像是给类起了一个高贵的名字，让它与众不同。所以，如果你想给你的类起个好听的名字，就要记得用大驼峰命名法，让它看起来更有气质。

记住，学习编程不仅要掌握技巧，还要有一点幽默感。

### **2.2 创建对象**

当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```python
对象变量 = 类名()
```



### **2.3 第一个面向对象程序**

需求：**小猫** 爱 **吃** 鱼，**小猫** 要 **喝** 水

分析

- 定义一个猫类 Cat
- 定义两个方法 eat 和 drink
- 按照需求 —— 不需要定义属性

![eb4513b453efb830a813b02ff6342b10](https://flower-1324274955.cos.ap-shanghai.myqcloud.com/eb4513b453efb830a813b02ff6342b10.png)

```python
class Cat:
    """这是一个猫类"""
    def eat(self):
        print("小猫爱吃鱼")
    def drink(self):
        print("小猫在喝水")
        
tom = Cat()
tom.drink()
tom.eat()
```



**引用概念的强调**：

在面向对象开发中，**引用**的概念是同样适用的！



- 在 Python 中使用类 **创建对象之后**，tom 变量中 仍然记录的是 **对象在内存中的地址**
- 也就是 tom 变量 引用 了 新建的猫对象
- 使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示）



**提示**：在计算机中，通常使用 **十六进制** 表示 **内存地址**



- **十进制** 和 **十六进制** 都是用来表达数字的，只是表示的方式不一样
- **十进制** 和 **十六进制** 的数字之间可以来回转换
- %d 可以以 10 进制 输出数字
- %x 可以以 16 进制 输出数字



案例进阶 —— 使用 Cat 类再创建一个对象

```
lazy_cat = Cat()
lazy_cat.eat()
lazy_cat.drink()
```

提问：tom 和 lazy_cat 是同一个对象吗？



## **3. 方法中的 self 参数**

### **3.1 案例改造 —— 给对象增加属性**

在 Python 中，要 **给对象设置属性**，非常的容易，**但是不推荐使用**

- 因为：对象属性的封装应该封装在类的内部

只需要在 **类的外部的代码** 中直接通过 . 设置一个属性即可

注意：这种方式虽然简单，但是不推荐使用！

```python
tom.name = "Tom"
...
lazy_cat.name = "大懒猫"
```



### **3.2 使用 self 在方法内部输出每一只猫的名字**



当你调用一个方法时，你可能会好奇，方法内部的`self`到底是指哪个对象的引用呢？让我来告诉你：



- 在类封装的方法内部，`self`就代表着当前调用该方法的对象自己。嗯，就是它自己！
- 当你调用一个方法时，你不需要手动传递`self`参数。它会自动传递给方法，就像魔法一样！
- 在方法内部，你可以通过`self.`来访问对象的属性。就像你在家里找东西一样，`self.`帮助你找到了对象的属性！
- 还可以通过`self.`调用其他对象的方法。就像你给朋友打电话一样，`self.`帮助你联系到了其他对象的方法！



所以，记住，当你调用一个方法时，方法内部的`self`就是指调用方法的对象自己。它是一个特殊的引用，让你可以轻松访问对象的属性和调用其他方法。开心编程！

改造代码如下：

```python
class Cat:
    def eat(self):
        print("%s 爱吃鱼" % self.name)
        
tom = Cat()
tom.name = "Tom"
tom.eat()
lazy_cat = Cat()
lazy_cat.name = "大懒猫"
lazy_cat.eat()
```

![b0b361177fdae444e651b1bd38d8c3f0](https://flower-1324274955.cos.ap-shanghai.myqcloud.com/b0b361177fdae444e651b1bd38d8c3f0.png)

- 在**类的外部**，通过`变量名.属性名`访问对象的属性，通过`变量名.方法名()`访问对象的方法。
- 在**类封装的方法中**，通过`self.属性名`访问对象的属性，通过`self.方法名()`访问对象的方法。



## **4. 初始化方法**

### **4.1 在类的外部给对象增加属性**

- 将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果

    ```python
    tom = Cat()
    tom.drink()
    tom.eat()
    tom.name = "Tom"
    print(tom)
    ```
    
- 程序执行报错如下：

    ```
    AttributeError: 'Cat' object has no attribute 'name'属性错误：'Cat' 对象没有 'name' 属性
```

**提示**：

- 在日常开发中，我们通常不建议在**类的外部**为对象添加属性，因为这可能会导致在运行时找不到属性而引发错误。
- 对象应该封装在类的内部，以确保属性的安全性和一致性。在类的内部，我们可以定义对象应该具有的属性，并通过方法来访问和修改这些属性。这样可以更好地控制对象的状态和行为，提高代码的可维护性和可扩展性。



### **4.2 初始化方法**

- 当我们使用 `类名()` 来创建对象时，Python会自动执行一些操作，让我们来看看都有哪些操作吧：

    所以，我们可以在`Cat`类中增加一个`__init__`方法来验证它在创建对象时会被自动调用。让我们来试试吧！

    1. 首先，Python会为对象在内存中分配一块空间，也就是创建对象。
    2. 接下来，Python会为对象的属性设置初始值，这个操作是通过一个特殊的方法来完成的，就是`__init__`方法。
    3. `__init__`方法是对象的内置方法，它的作用是定义一个类具有哪些属性。

```python
class Cat:
    """这是一个猫类"""
    def __init__(self):
        print("初始化方法")
```



### **4.3 在初始化方法内部定义属性**

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以定义属性。这样一来，每次使用 Cat 类创建的对象都会自动拥有这个属性。就像是给猫咪穿上了一件新衣服，它们都会拥有这个属性，而且初始值也已经设置好了。这样，我们就可以在后续的代码中使用这个属性来存储和访问相关的信息了。

```python
class Cat:
    def __init__(self):
        print("这是一个初始化方法")
        # 定义用 Cat 类创建的猫对象都有一个 name 的属性
        self.name = "Tom"
    def eat(self):
        print("%s 爱吃鱼" % self.name)
        #使用类名()创建对象的时候，会自动调用初始化方法 __init__
        
tom = Cat()
tom.eat()
```



### **4.4 改造初始化方法 —— 初始化的同时设置初始值**

在开发中，如果我们希望在创建对象的同时就设置对象的属性，可以对 `__init__` 方法进行改造：



1. 首先，我们将希望设置的属性值定义为 `__init__` 方法的参数。
2. 然后，在方法内部使用 `self.属性 = 形参` 的方式来接收外部传递的参数。
3. 最后，在创建对象时，我们可以使用 `类名(属性1, 属性2...)` 的方式来调用这个方法，从而实现在创建对象的同时设置属性的目的。



这样，我们就可以方便地在创建对象时一次性设置多个属性，提高了代码的可读性和灵活性。希望这个小技巧对你有所帮助！

```python
class Cat:
    def __init__(self, name):
        print("初始化方法 %s" % name)
        self.name = name
        ...
        
tom = Cat("Tom")
...
lazy_cat = Cat("大懒猫")
...
```



## **5. 内置方法和属性**

| **方法名** | **类型** | **作用**                                     |
| ---------- | -------- | -------------------------------------------- |
| `__del__`  | 方法     | **对象被从内存中销毁**前，会被 **自动** 调用 |
| `__str__`  | 方法     | 返回**对象的描述信息**，print 函数输出使用   |

### **5.1** `__del__` 方法（知道）

在 Python 中，我们可以使用类来创建对象。当我们使用类名后面跟着一对括号来创建对象时，Python 会为对象分配内存空间，并自动调用 `__init__` 方法来初始化对象。

同样地，当一个对象即将被销毁时，Python 也会自动调用 `__del__` 方法。这个方法可以让我们在对象被销毁前做一些额外的操作。

这两个方法在 Python 中的应用场景如下：

- `__init__` 方法可以被用来改造初始化过程，使得对象的创建更加灵活。
- `__del__` 方法可以在对象被销毁前执行一些必要的清理操作。

一个对象的生命周期从调用类名后面的括号开始，直到 `__del__` 方法被调用为止。在对象的生命周期内，我们可以访问对象的属性，并调用对象的方法。这使得我们可以在对象的整个生命周期中对其进行操作。

所以，记住，在 Python 中，对象的创建和销毁都是自动完成的，而 `__init__` 和 `__del__` 方法则为我们提供了在对象生命周期中进行额外操作的机会。

```python
class Cat:
    def __init__(self, new_name):
        self.name = new_name
        print("%s 来了" % self.name)
    def __del__(self):
        print("%s 去了" % self.name)
        
# tom 是一个全局变量
tom = Cat("Tom")
print(tom.name)
# del 关键字可以删除一个对象
del tom
print("-" * 50)
```

### **5.2 str 方法**

- 在Python中，我们可以使用`print`语句来输出对象变量。默认情况下，它会显示这个变量引用的对象是由哪个类创建的，并显示对象在内存中的地址（以十六进制表示）。

    然而，在开发过程中，如果我们希望在打印对象变量时能够显示自定义的内容，那么我们可以利用`__str__`这个内置方法。

    `__str__`方法是一个特殊的方法，它必须返回一个字符串。当我们使用`print`语句打印对象变量时，Python会自动调用该对象的`__str__`方法，并将其返回的字符串作为输出结果。

    通过在类中定义`__str__`方法，我们可以控制对象在被打印时的输出内容，使其更符合我们的需求。这样，我们就能够以更加自定义的方式显示对象的信息了。

    希望这个解释能够帮助你理解如何使用`__str__`方法来自定义打印对象变量的内容。

```python
class Cat:
    def __init__(self, new_name):
        self.name = new_name
        print("%s 来了" % self.name)
    def __del__(self):
        print("%s 去了" % self.name)
    def __str__(self):
        return "我是小猫：%s" % self.name
    
tom = Cat("Tom")
print(tom)
```