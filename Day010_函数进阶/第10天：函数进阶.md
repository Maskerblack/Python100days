# 100天精通Python（基础篇）——第10天：



### **目标**

- 函数参数和返回值的作用：让你的函数变得更有料！
- 函数的返回值 进阶：让你的函数变得更有价值！
- 函数的参数 进阶：让你的函数变得更有逼格！
- 递归函数：让你的函数变得更有深度！

### **一. 函数参数和返回值的作用**

函数就像是一家餐厅，参数和返回值就是餐厅的菜单和上菜的方式，它们可以以各种方式组合，一共有4种组合形式。

1. 无参数，无返回值：就像是一家没有菜单也不上菜的餐厅，你只能进去坐坐，什么都吃不到。
2. 无参数，有返回值：就像是一家没有菜单但是会上菜的餐厅，你不知道有什么可选的，但是至少你能吃到一些好吃的。
3. 有参数，无返回值：就像是一家有菜单但是不上菜的餐厅，你可以点菜，但是你吃不到任何东西。
4. 有参数，有返回值：就像是一家有菜单也会上菜的餐厅，你可以点菜，而且你会得到你想要的美味佳肴。

所以，记住，函数的参数和返回值可以让你的函数变得更有料、更有价值、更有逼格、更有深度！

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSR59icNNnQicrEzpbzmTK8wichWrWwHwx1rcQc7VDwxzphrEapcFccEk6A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> 定义函数时，**是否接收参数，或者是否返回结果**，是根据 **实际的功能需求** 来决定的！

1. 如果函数 **内部处理的数据不确定**，就可以将外界的数据以参数传递到函数内部
2. 如果希望一个函数 **执行完成后，向外界汇报执行结果**，就可以增加函数的返回值

#### **1.1 无参数，无返回值**

此类函数就像一个宅男，不需要外界的刺激，也不会给你任何回应，但它们在某些场景下还是非常有用的：

1. **只是单纯地做一件事情**，就像你在家里无聊地看着电视，不需要任何人陪伴，只是为了消磨时间。这类函数就像是一个电视节目，只是负责显示菜单，告诉你有哪些选项可以选择。它们不需要任何参数，也不会返回任何值，只是单纯地展示给你看。
2. 在函数内部 **针对全局变量进行操作**，就像你在家里整理你的名片夹一样。这类函数会对全局变量进行操作，就像你在整理名片时，会新增一张名片，并将最终结果记录在名片夹中。虽然这类函数不接收任何参数，也不返回任何值，但它们会对全局变量产生影响，让你的程序变得更加有条理。

希望通过这个幽默的比喻，你能更好地理解这类函数的应用场景！记住，它们就像是一个宅男和一个整理名片的人，虽然有些懒散，但在适当的时候，它们还是非常有用的！

> 注意：

- 如果一个全局变量的数据类型是个**可变类型**，在函数内部，我们是可以使用**方法**来修改全局变量的内容的哦！是不是很神奇？就像是变量的引用不会改变一样，我们可以随心所欲地改变它的内容。
- 不过，要注意啦！在函数内部，如果你想要**修改变量的引用**，就得使用赋值语句了。这可是个重要的技巧哦！只有通过赋值语句，我们才能成功改变变量的引用，让它指向新的对象。

记住这两个小技巧，你就能在Python的世界里自由驰骋了！快去试试吧！🚀

#### **1.2 无参数，有返回值**

这种函数就像一个自动取温度的温度计，它不需要你提供任何参数，但是它会给你返回当前的温度。这样你就可以轻松地知道现在是不是该穿厚一点了。

#### **1.3 有参数，无返回值**

这种函数就像一个名片管理系统，它需要你提供一个名片作为参数，然后它会根据你提供的名片来进行不同的操作，比如修改或删除。虽然它不会给你返回任何结果，但是它会帮助你处理不同的数据，让你的名片管理更加方便。

#### **1.4 有参数，有返回值**

这种函数就像一个智能的名片管理系统，它不仅需要你提供一个名片作为参数，还会根据你提供的名片来进行不同的操作，并且会给你返回一个处理结果。比如，它可以使用字典默认值和提示信息来提示你输入内容，如果你输入了内容，它会返回你输入的内容，如果没有输入，它会返回字典默认值。这样，你就可以轻松地管理你的名片，并且得到你期望的处理结果。

### **二. 函数的返回值**

在程序开发中，有时候我们希望一个函数执行结束后能够告诉我们一个结果，这样我们就可以根据具体的结果来做后续的处理了。这个结果就是函数的返回值，它是函数完成工作后给我们的一个结果。

我们可以使用 `return` 关键字来返回结果。当我们调用一个函数时，可以使用一个变量来接收函数的返回结果，这样我们就可以方便地使用这个结果进行后续的操作了。

> 问题：一个函数能否返回多个结果呢？

#### **示例 —— 温度和湿度测量**

假设我们要开发一个函数，能够同时返回当前的温度和湿度。我们可以先实现返回温度的功能，代码如下：

```python
def measure():
    """返回当前的温度"""
    print("开始测量...")
    temp = 39
    print("测量结束...")
    return temp
result = measure()
print(result)
```

- 在利用 **元组** 在返回温度的同时，也能够返回 **湿度**
- 改造如下：

```python
def measure():
    """返回当前的温度"""
    print("开始测量...")
    temp = 39
    wetness = 10
    print("测量结束...")
    return (temp, wetness)
```

> 提示：如果一个函数返回的是元组，括号可以省略

**技巧**

- 在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**
- 注意：变量的数量需要和元组中的元素数量保持一致

```python
result = temp, wetness = measure()
```

#### **面试题 —— 交换两个数字**

**题目要求**

1. 有两个整数变量 `a = 6`, `b = 100`
2. 不使用其他变量，**交换两个变量的值**

##### **解法 1 —— 使用其他变量**

```python
# 解法 1 - 使用临时变量
c = b
b = a
a = c
```

##### **解法 2 —— 不使用临时变量**

```python
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b
```

##### **解法 3 —— Python 专有，利用元组**

```python
a, b = b, a
```

### **三. 函数的参数**

#### **3.1. 不可变和可变的参数**

> 问题 1：在函数内部，针对参数使用 **赋值语句**，会不会影响调用函数时传递的 **实参变量**？—— 不会！

- 无论传递的参数是 **可变** 还是 **不可变**
    - 只要 **针对参数** 使用 **赋值语句**，会在 **函数内部** 修改 **局部变量的引用**，**不会影响到 外部变量的引用**

嘿，小伙伴们！来聊聊函数参数的事情吧！你们知道吗，在函数内部，我们可以对参数进行赋值操作，但是这不会影响到我们调用函数时传递的实参变量哦！不管是可变的还是不可变的参数，只要我们在函数内部使用赋值语句，那只会修改函数内部的局部变量引用，而不会影响到外部变量的引用。所以，放心大胆地在函数里面玩赋值吧！不会有任何副作用的哦！

```python
def demo(num, num_list):
    print("函数内部")
    # 赋值语句
    num = 200
    num_list = [1, 2, 3]
    print(num)
    print(num_list)
    print("函数代码完成")
    
gl_num = 99
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

> 问题 2：如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据**

```python
def mutable(num_list):
    # num_list = [1, 2, 3]
    num_list.extend([1, 2, 3])
    print(num_list)

gl_list = [6, 7, 8]
mutable(gl_list)
print(gl_list)
```

##### **面试题 ——** `+=`

- 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num, num_list):
    print("函数内部代码")
    # num = num + num
    num += num    
    # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用    
    # 函数执行结束后，外部数据同样会发生变化    
    num_list += num_list    
    print(num)    
    print(num_list)    
    print("函数代码完成")
    
gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
```

#### **3.2 缺省参数**

- 嘿，小伙伴们！在Python的世界里，我们可以给**某个参数**设定一个超级酷炫的**默认值**，这样的参数就被称为**缺省参数**。是不是感觉很高大上？
- 当我们调用函数时，如果没有给**缺省参数**传入值，那么函数就会使用我们在定义函数时指定的**参数默认值**。这就像是在玩捉迷藏，如果你不去找，Python就会用默认值来代替！
- 使用缺省参数的好处是，我们可以把常见的值设置为参数的默认值，这样就能让函数的调用变得超级简单。就像是给自己准备了一个超级方便的快捷通道！
- 比如说，我们要对一个列表进行排序，Python给我们提供了一种超级方便的方法。就像是有个魔法师一样，只需要调用`sort()`方法，就能让列表按照顺序排列起来。是不是觉得自己变成了魔法师呢？

记住，学习Python不仅要认真，还要有点幽默感！这样才能更好地掌握这门语言的精髓。继续加油，成为Python的大神！

- 
- 
- 
- 
- 
- 
- 

```
gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list)
```

##### **指定函数的缺省参数**

- 在参数后使用赋值语句，可以指定参数的缺省值

- 
- 
- 
- 
- 

```
def print_info(name, gender=True):    gender_text = "男生"    if not gender:        gender_text = "女生"    print("%s 是 %s" % (name, gender_text))
```

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！
2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递！

##### **缺省参数的注意事项**

###### **1) 缺省参数的定义位置**

- 必须保证 **带有默认值的缺省参数** 在参数列表末尾
- 所以，以下定义是错误的！

根据提示，我们在定义函数时，如果需要设置缺省参数，应该将最常见的值作为默认值。这样，在调用函数时，如果没有传递该参数的值，就会使用默认值。但是，如果一个参数的值不能确定，就不应该设置默认值，而是在调用函数时由外界传递具体的数值。

另外，需要注意的是，带有默认值的缺省参数必须放在参数列表的末尾。这样才能保证函数的调用不会出错。

所以，记住这些注意事项，以免在定义函数时出现错误。

- 

```
def print_info(name, gender=True, title):
```

###### **2) 调用带有多个缺省参数的函数**

- 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**，这样解释器才能够知道参数的对应关系！

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
def print_info(name, title="", gender=True):    """    :param title: 职位    :param name: 班上同学的姓名    :param gender: True 男生 False 女生    """    gender_text = "男生"    if not gender:        gender_text = "女生"    print("%s%s 是 %s" % (title, name, gender_text)) # 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info("小明")print_info("老王", title="班长")print_info("小美", gender=False)
```

#### **3.3 多值参数（知道）**

##### **定义支持多值参数的函数**

有时候，我们会遇到一个问题，就是不确定有多少人要一起吃饭，这时候就需要一个函数能够处理不确定个数的参数。这就是多值参数的用武之地啦！

在`python`中，我们有两种多值参数的写法：

- 如果在参数名前面加上一个`*`，那么这个参数就可以接收一个元组。就像是一个大餐桌，可以容纳很多人。
- 如果在参数名前面加上两个`*`，那么这个参数就可以接收一个字典。就像是一个大菜单，可以点很多菜。

我们一般习惯给多值参数起以下两个名字：

- `*args` —— 这个参数是用来存放元组的，所以前面有一个`*`，就像是一个大桌子，可以坐很多人。
- `**kwargs` —— 这个参数是用来存放字典的，所以前面有两个`*`，就像是一个大菜单，可以点很多菜。

记住，`args`是`arguments`的缩写，表示这是一个变量。而`kw`是`keyword`的缩写，`kwargs`就是用来存放键值对参数的。

所以，当你遇到不确定个数的参数时，就可以使用多值参数来解决啦！

- 
- 
- 
- 
- 
- 

```
def demo(num, *args, **kwargs):    print(num)    print(args)    print(kwargs) demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)
```

> 提示：**多值参数** 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，**有利于我们能够读懂大牛的代码**

##### **多值参数案例 —— 计算任意多个数字的和**

**需求**

1. 定义一个函数 `sum_numbers`，可以接收的 **任意多个整数**
2. 功能要求：将传递的 **所有数字累加** 并且返回累加结果

- 
- 
- 
- 
- 
- 
- 

```
def sum_numbers(*args):    num = 0    # 遍历 args 元组顺序求和    for n in args:        num += n    return numprint(sum_numbers(1, 2, 3))
```

##### **元组和字典的拆包（知道）**

- 在调用带有多值参数的函数时，如果希望：
    - 将一个 **元组变量**，直接传递给 `args`
    - 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
    - 在 **元组变量前**，增加 **一个** `*`
    - 在 **字典变量前**，增加 **两个** `*`

- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

```
def demo(*args, **kwargs):    print(args)    print(kwargs) # 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = {"name": "小明", "age": 18}# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)demo(*gl_nums, **gl_xiaoming)
```

### **四. 函数的递归**

> 函数调用自身的 **编程技巧** 称为递归

#### **4.1 递归函数的特点**

**特点**

- **一个函数** **内部** **调用自己**
    - 函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行
    - **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！

示例代码

- 
- 
- 
- 
- 
- 
- 
- 
- 

```
def sum_numbers(num):    print(num)        # 递归的出口很重要，否则会出现死循环    if num == 1:        return    sum_numbers(num - 1)    sum_numbers(3)
```

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSNP4HfJYpcxYPzicuP3cEibLHZrbCAUWvlfw68Qq8umCn4ppB9PpyFdyw/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)**4.2 递归案例 —— 计算数字累加**

**需求**

1. 定义一个函数 `sum_numbers`
2. 能够接收一个 `num` 的整数参数
3. 计算 1 + 2 + … num 的结果

- 
- 
- 
- 
- 
- 
- 
- 
- 

```
def sum_numbers(num):    if num == 1:        return 1        # 假设 sum_numbers 能够完成 num - 1 的累加    temp = sum_numbers(num - 1)    # 函数内部的核心算法就是 两个数字的相加    return num + tempprint(sum_numbers(2))
```

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdaOZ6NPeG54R6fwGwU33TwSdRmsPLsmM1LVFZH8dibNCLAibIQvOl0oDh4KlUOIjaUrrutcklw1qticQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外的有用，例如：**遍历整个文件目录的结构**