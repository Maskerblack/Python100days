# 100天精通Python（基础篇）——第15天：继承

**面向对象三大特性**

- **封装**：就像把自己关在房间里一样，把属性和方法装进一个抽象的类中，以便根据职责进行管理。
- **继承**：就像借用朋友的衣服一样，可以重复使用相同的代码，避免重复劳动。
- **多态**：就像变魔术一样，不同的对象调用相同的方法，却能产生不同的执行结果，让代码更加灵活多变。

## **1. 单继承**

### **1.1 继承的概念、语法和特点**

继承就像是一个孩子继承了父母的基因一样，子类也可以继承父类的方法和属性。这样，子类就可以拥有父类的一切，就像是继承了一个超级能力一样！

在Python中，继承的语法很简单。只需要在定义子类时，在类名后面加上父类的名字，用括号括起来。这样，子类就可以继承父类的一切啦！

继承的特点是，子类可以使用父类的方法和属性，而且还可以添加自己特有的方法和属性。这就像是在继承父类的基础上，再加上一些个性化的东西，让子类变得更加强大和独特！

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdabY9h32YRrp2FQnlWcuH4W0JdJ6BibQZo5e4feEgXicicFMuIZtCboVcSpFFOCrJm8PI7zWN0N6XMyg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**1) 继承的语法**

```python
class 类名(父类名):
    pass
```

- 子类继承自父类，就像是小狗继承了动物一样。这意味着子类可以直接享受父类中已经封装好的方法，就像小狗不需要再次开发动物的功能一样。
- 子类应该根据自己的职责，封装一些特有的属性和方法，就像小狗会有自己特有的叫声和玩耍方式一样。

**2) 专业术语**

- Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承了一些功能。
- Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生出来。

**3) 继承的传递性**

```python
C 类从 B 类继承，B 类又从 A 类继承
那么 C 类就具有 B 类和 A 类的所有属性和方法
```

哮天犬可怜巴巴地望着Cat类的catch方法，心想着能不能调用一下呢？可惜的是，哮天犬和Cat之间并没有继承关系，所以它是无法直接调用Cat类中定义的catch方法的。就像你不能从天上掉下来，然后变成猫一样，这是超出了哮天犬的能力范围啊！所以，哮天犬只能默默地望着Cat类的catch方法，心生羡慕之情。

### **1.2 方法的重写**

- 子类继承了父类的所有方法和属性，就像继承了父母的遗传基因一样，不需要重新开发。

**应用场景**

- 当父类的方法不能满足子类的需求时，就像父母的衣服不合适孩子一样，可以对方法进行重写(override)。

![2d5364c50856d5181d996a1c3fc91104](https://flower-1324274955.cos.ap-shanghai.myqcloud.com/2d5364c50856d5181d996a1c3fc91104.png)

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法：就像是你在家里重装修一样，将父类的方法完全改造成自己想要的样子。
2. 对父类方法进行 **扩展**：这就像是在原有房子的基础上增加一间新房间，保留了原有的功能，同时又增加了新的功能。

**1) 覆盖父类的方法**

- 当父类的方法实现和子类的方法实现完全不同的时候，我们可以使用覆盖的方式，在子类中重新编写父类的方法实现。
- 具体的实现方式就是在子类中定义一个和父类同名的方法，并且实现自己想要的功能。

> 重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法。这就像是你在家里装修后，只会使用新装修的房间，而不再使用原来的房间。

**2) 对父类方法进行 扩展**

- 子类的方法实现中需要包含父类的方法实现
    - 我们可以使用一种叫做“扩展”的方式。
    - 第一步，你需要在子类中重写父类的方法。就是把父类原本封装的方法实现改成子类方法的一部分。
    - 第二步，当你需要调用父类的方法时，在需要的位置使用`super().父类方法`来调用父类方法的执行。
    - 第三步，根据子类的需求，在其他代码位置编写子类特有的代码实现。

**关于super**

- 哎呀，super在Python中是一个特殊的类哦！
- 使用`super()`就是使用super类创建出来的对象。
- 最常见的使用场景就是在重写父类方法时，调用在父类中封装的方法实现。

还有一种调用父类方法的方式（知道）

- 哈哈，听说在Python 2.x时，如果需要调用父类的方法，还可以使用以下方式：

    - 

    ```
    父类名.方法(self)
    ```

- 嗨！在 Python 3.x 中，你还可以使用这种方式哦！不过，我要提醒你一下，这种方法并不被推荐使用哦！因为一旦父类发生变化，你不仅需要修改方法调用位置的类名，还需要修改方法内部的父类名。这样一来，修改起来可就麻烦了呢！

- 嘿，我有个小提示给你哦！在开发时，尽量不要混用父类名和super()这两种方式哦！不然会让代码看起来有点混乱呢！

- 还有一个小小的注意事项，如果你使用当前子类名来调用方法，可能会导致**递归调用**，进而陷入**死循环**哦！所以，小心使用哦！

示例

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/klS3icnSibsdabY9h32YRrp2FQnlWcuH4WibiaAUcvZD6lI8FribCX4znsTYzicKicnTZ4ibO7OjQnZwUHYvazibfQpSj3A/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 对象 B 无法直接访问 `__num2` 属性，这是因为该属性被定义为私有属性，只能在类内部访问。
- 在对象 B 的 `demo` 方法内部，同样无法访问 `__num2` 属性。私有属性只能在类的内部使用。
- 不过，对象 B 在 `demo` 方法内部是可以调用父类的 `test` 方法的。这是因为继承关系使得子类可以访问父类的公有方法。
- 在父类的 `test` 方法内部，可以访问 `num2` 属性和 `test` 方法本身。这是因为这些属性和方法都是父类的公有成员，可以在类内部和外部访问。

## **2. 多继承**

**概念**

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

<img src="https://flower-1324274955.cos.ap-shanghai.myqcloud.com/218db625e1116e1fa416284ce79787d9.png" alt="218db625e1116e1fa416284ce79787d9" style="zoom: 50%;" />

**语法**

```
class 子类名(父类名1, 父类名2...)    pass
```

### **2.1 多继承的使用注意事项**

**问题的提出**

- 如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？

> 提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承

<img src="https://flower-1324274955.cos.ap-shanghai.myqcloud.com/640" alt="图片" style="zoom:50%;" />

**Python 中的 MRO —— 方法搜索顺序（知道）**

- Python 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 方法 搜索顺序

- MRO 是 method resolution order，主要用于 **在多继承时判断 方法、属性 的调用 路径**

    - 

    ```
    print(C.__mro__)
    ```

    输出结果

    - 

    ```
    (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
    ```

- 在搜索方法时，就像是在找寻宝藏一样，我们按照 `mro` 的输出结果从左至右的顺序进行搜索。

- 如果在当前类中找到了方法，那就像是找到了宝藏一样，我们直接执行它，不再继续搜索其他类。

- 如果没有在当前类中找到方法，我们就像是继续寻宝一样，继续在下一个类中查找是否有对应的方法。如果找到了，我们也是直接执行它，不再继续搜索其他类。

- 如果我们已经找到了最后一个类，却依然没有找到方法，那就像是找遍了整个宝藏地图却一无所获，程序会报错，提示我们宝藏不存在。

所以，记住在Python中，按照这个顺序搜索方法，就像是在寻宝一样，找到了就执行，找不到就报错。保持好奇心，继续探索宝藏吧！

### **2.2 新式类与旧式（经典）类**

> > `object` 是 Python 为所有对象提供的基类，它有一些内置的属性和方法，你可以使用 `dir` 函数来查看。
>
> - 新式类：这是一种以 `object` 为基类的类，非常推荐使用哦！
> - 经典类：这是一种不以 `object` 为基类的类，不太推荐使用呢。
> - 在 Python 3.x 中，如果你在定义类时没有指定父类，那么默认会使用 `object` 作为该类的基类。所以在 Python 3.x 中定义的类都是新式类哦。
> - 在 Python 2.x 中，如果你在定义类时没有指定父类，那么它就不会以 `object` 作为基类。
>
> > 当涉及到多继承时，新式类和经典类会影响方法的搜索顺序哦。
>
> 为了保证你的代码能够同时在 Python 2.x 和 Python 3.x 运行，建议在定义类时，如果没有父类，统一继承自 `object`。这样可以让你的代码更加兼容哦！



```python
class 类名(object):
    pass
```